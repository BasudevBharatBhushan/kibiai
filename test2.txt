data:text/html,<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
<<_style_>>
</head>

<body>
    <div id="loader"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 9999;">
        <div
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 30px 50px; border-radius: 5px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2); text-align: center;">
            <p style="margin: 0; font-family: Arial, sans-serif; font-size: 16px; color: #333;">Hang tight! We're
                putting your report together for saving. Almost there... </p>
        </div>
    </div>
    <div id="main-div">
        <div class="report-controls">

                      <div class="pagination-controls">
                <div style="display: flex; align-items: center; gap: 5px;">
                    <button class="pagination-button" id="prevPage" disabled>
                        <i class="fas fa-chevron-left"></i>
                    </button>
                    <span class="pagination-info">Page <span id="currentPage">1</span> of <span
                            id="totalPages">1</span></span>
                    <button class="pagination-button" id="nextPage">
                        <i class="fas fa-chevron-right"></i>
                    </button>
                </div>
                <div class="control-group">
                    <button class="control-button" onclick=" exportPdf()">PDF</button>
                    <button class="control-button" onclick="exportTableToServer()">Excel</button>

                </div>
            </div>
        </div>

        <div id="dynamic-report"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"
        integrity="sha512-GsLlZN/3F2ErC5ifS5QtgpiJtWd43JWSuIgh7mbzZ8zBps+dvLusV+eNQATqgA/HdeKFVgA5v3S/cIrLF7QnIg=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script>
        const fontButtons = document.querySelectorAll('.font-button');
        const reportElement = document.querySelector('.dynamic-report');
        fontButtons.forEach(button => {
            button.addEventListener('click', () => {
                const currentReportElement = document.querySelector('.dynamic-report');
                if (!currentReportElement) {
                    console.warn('No .dynamic-report found at click time!');
                    return;
                }

                fontButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                const selectedFont = button.getAttribute('data-font');

                currentReportElement.classList.remove('inter-font', 'playfair-font', 'roboto-mono-font', 'open-sans-font');
                currentReportElement.classList.add(`${selectedFont}-font`);

                console.log('Font changed to:', selectedFont);
            });

        });

        var tableData = "";
        let insightData = "";
        const itemsPerPage = 10;
        let pagination = "";
        const jsonData = <multi_table_report_data>
        const fieldPrefix = jsonData.find(item => item.Body && item.Body.FieldPrefix) || {};
        const prefixMap = fieldPrefix.Body?.FieldPrefix || {};
        const filemakerBridge = window.Filemaker;
        function initializeThemeSwitcher() {
            const reportElement = document.querySelector('.dynamic-report');
            const themeButtons = document.querySelectorAll('.theme-button');
            themeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Remove all theme classes
                    reportElement.classList.remove('classic-theme', 'modern-theme', 'elegant-theme');
                    // Add selected theme class
                    const selectedTheme = button.dataset.theme;
                    reportElement.classList.add(`${selectedTheme}-theme`);
                    // Update active button state
                    themeButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                });
            });
        }

        function initializeA4Pagination() {
            // A4 dimensions in pixels (at 96 DPI)
            // A4 is 210mm × 297mm
            // Accounting for your 10mm padding on each side
            const A4_WIDTH = 794; // ~210mm at 96 DPI
            const A4_HEIGHT = 1123; // ~297mm at 96 DPI
            const PAGE_PADDING = 38; // ~10mm padding
            const CONTENT_HEIGHT = A4_HEIGHT - (PAGE_PADDING * 6);

            let currentPageIndex = 1;
            let totalPages = 0;

            // Collect all top-level subsummary elements
            const topLevelSubsummaries = Array.from(document.querySelectorAll('.dynamic-report > .subsummary.level-0'));

            // Function to calculate pages based on content height
            function calculatePages() {
                // Create a temporary container to measure content
                const tempContainer = document.createElement('div');
                tempContainer.className = 'dynamic-report';
                tempContainer.style.visibility = 'hidden';
                tempContainer.style.position = 'absolute';
                tempContainer.style.width = (A4_WIDTH - (PAGE_PADDING * 2)) + 'px';
                tempContainer.style.padding = PAGE_PADDING + 'px';
                document.body.appendChild(tempContainer);

                // Array to store page breaks
                const pageBreaks = [];
                let currentHeight = 0;
                let currentPage = [];

                // Calculate which elements go on which page
                topLevelSubsummaries.forEach((summary) => {
                    // Clone the element to measure its height
                    const clone = summary.cloneNode(true);
                    tempContainer.appendChild(clone);
                    const elementHeight = clone.offsetHeight;
                    tempContainer.removeChild(clone);

                    // If adding this element exceeds page height, start a new page
                    if (currentHeight + elementHeight > CONTENT_HEIGHT && currentPage.length > 0) {
                        pageBreaks.push([...currentPage]);
                        currentPage = [summary];
                        currentHeight = elementHeight;
                    } else {
                        currentPage.push(summary);
                        currentHeight += elementHeight;
                    }
                });

                // Add the last page if it has content
                if (currentPage.length > 0) {
                    pageBreaks.push(currentPage);
                }

                // Clean up
                document.body.removeChild(tempContainer);

                return pageBreaks;
            }

            // Calculate initial page distribution
            const pages = calculatePages();
            totalPages = pages.length;
            document.getElementById('totalPages').textContent = totalPages;

            function updatePageDisplay() {
                // Hide all subsummaries first
                topLevelSubsummaries.forEach(summary => {
                    summary.style.display = 'none';
                });

                // Show only subsummaries for current page
                if (pages[currentPageIndex - 1]) {
                    pages[currentPageIndex - 1].forEach(summary => {
                        summary.style.display = 'block';
                    });
                }

                const trailingSummary = document.querySelector('.trailing-summary');
                if (trailingSummary) {
                    trailingSummary.style.display = (currentPageIndex === totalPages) ? 'block' : 'none';
                }
                // Update pagination controls
                document.getElementById('currentPage').textContent = currentPageIndex;
                document.getElementById('prevPage').disabled = currentPageIndex === 1;
                document.getElementById('nextPage').disabled = currentPageIndex === totalPages;
            }

            // Setup event listeners for pagination buttons
            document.getElementById('prevPage').addEventListener('click', () => {
                if (currentPageIndex > 1) {
                    currentPageIndex--;
                    updatePageDisplay();
                }
            });

            document.getElementById('nextPage').addEventListener('click', () => {
                if (currentPageIndex < totalPages) {
                    currentPageIndex++;
                    updatePageDisplay();
                }
            });

            // Handle window resize - recalculate pages if the window dimensions change
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    // Recalculate pages on resize
                    const oldPage = currentPageIndex;
                    pages.length = 0;
                    Array.prototype.push.apply(pages, calculatePages());
                    totalPages = pages.length;
                    document.getElementById('totalPages').textContent = totalPages;

                    // Ensure current page is still valid
                    currentPageIndex = Math.min(oldPage, totalPages);
                    updatePageDisplay();
                }, 200); // Debounce resize events
            });

            // Initial display
            updatePageDisplay();

            // Return methods to allow manual control if needed
            return {
                getCurrentPage: () => currentPageIndex,
                getTotalPages: () => totalPages,
                goToPage: (pageNum) => {
                    if (pageNum > 0 && pageNum <= totalPages) {
                        currentPageIndex = pageNum;
                        updatePageDisplay();
                    }
                },
                recalculatePages: () => {
                    const oldPage = currentPageIndex;
                    pages.length = 0;
                    Array.prototype.push.apply(pages, calculatePages());
                    totalPages = pages.length;
                    document.getElementById('totalPages').textContent = totalPages;
                    currentPageIndex = Math.min(oldPage, totalPages);
                    updatePageDisplay();
                }
            };
        }



        function generateDynamicReport(jsonData) {
            // Helper function to sort objects by multiple keys
            function multiSort(array, sortKeys) {
                return array.sort((a, b) => {
                    for (let key of sortKeys) {
                        const trimmedKey = key.trim();
                        if (a[trimmedKey] < b[trimmedKey]) return -1;
                        if (a[trimmedKey] > b[trimmedKey]) return 1;
                    }
                    return 0;
                });
            }

            // Helper function to group array by key
            function groupBy(array, key) {
                const trimmedKey = key.trim();
                return array.reduce((result, currentValue) => {
                    (result[currentValue[trimmedKey]] = result[currentValue[trimmedKey]] || []).push(currentValue);
                    return result;
                }, {});
            }

            // Generate Title Header
            function generateTitleHeader(titleHeader) {
                return `
            <div class="title-header">
                <<image_element>>
                <div>
                 <h1>${titleHeader.MainHeading}</h1>
                <h2><<company_subheader>></h2>
                    </div>

            </div>
        `;
            }

            // Generate nested subsummaries
            function generateNestedSubsummaries(data, subsummaries, level = 0, key = '') {
                tableData = tableData ? tableData + "_" + key : key;

                if (level >= subsummaries.length) {
                    tableData_ = tableData;
                    tableData = "";
                    return generateBodyTable(data, bodySortKeys, tableData_);
                }

                const currentSubsummary = subsummaries[level];
                const groupField = currentSubsummary.SubsummaryFields[0];
                const groupedData = groupBy(data, groupField);
                const sortOrder = (currentSubsummary.SortOrder || "asc").toLowerCase();
                  const groupedEntries = Object.entries(groupedData).sort(([aKey], [bKey]) => {
                    let result;
                    if (!isNaN(aKey) && !isNaN(bKey)) {
                        result = Number(aKey) - Number(bKey); // numeric compare
                    } else {
                        result = String(aKey).localeCompare(String(bKey)); // string compare
                    }
                    return sortOrder === "asc" ? result : -result;
                });
                const totals = currentSubsummary.SubsummaryTotal || [];
                const displayFields = currentSubsummary.SubsummaryDisplay || [];

                let html = '';

                for (let [groupValue, group] of groupedEntries) {
                    const groupFieldPrefix = prefixMap[groupField] || fieldPrefix[groupField.trim()] || '';
                    const groupFieldSuffix = fieldSuffix[groupField.trim()] || '';

                    // Create display information
                    let displayInfo = '';
                    displayFields.forEach(field => {
                        const trimmedField = field.trim();
                        const prefix = prefixMap[field] || fieldPrefix[trimmedField] || '';
                        const suffix = fieldSuffix[trimmedField] || '';
                        const value = group[0]?.[field] || '';
                        displayInfo += `<span class="display-item"><span class="display-label">${field}:</span> <span class="display-value">${prefix}${value}${suffix}</span></span>`;
                    });
                    // Create plain text version for insightData
                    let displayInfoText = '';
                    displayFields.forEach(field => {
                        const trimmedField = field.trim();
                        const prefix = prefixMap[field] || fieldPrefix[trimmedField] || '';
                        const suffix = fieldSuffix[trimmedField] || '';
                        const value = group[0]?.[field] || '';
                        displayInfoText += `${field}: ${prefix}${value}${suffix}, `;
                    });

                    
                    // Remove trailing comma and space
                    displayInfoText = displayInfoText.replace(/, $/, '');

                    // Use displayInfoText for insightData instead of displayInfo
                    insightData += `${groupField.trim()}-${groupValue} ${displayInfoText}; `;

                    // Calculate totals for this group
                    let groupTotals = {};
                    totals.forEach(field => {
                        const sum = group.reduce((acc, item) => {
                            const value = parseFloat(item[field]);
                            return acc + (isNaN(value) ? 0 : value);
                        }, 0);
                        groupTotals[field] = sum;
                    });

                    html += `
                <div class="subsummary level-${level}">
                    <h${level + 3} class="subsummary-header">
                        <span class="field-name">${groupField.trim()}</span>: ${groupFieldPrefix}${groupValue || 'N/A'}${groupFieldSuffix}
                    </h${level + 3}>
                    ${displayInfo ? `<div class="subsummary-display">${displayInfo}</div>` : ''}
                    <div class="subsummary-content">
                        ${generateNestedSubsummaries(group, subsummaries, level + 1, groupField.trim() + "-" + groupValue)}
                        ${totals.length > 0 ? generateSectionTotals(groupTotals, level) : ''}
                    </div>
                </div>
            `;

                  //  insightData += `${groupField.trim()}-${groupValue} ${displayInfo}; `;
                }

                return html;
            }

            // Generate section totals
            function generateSectionTotals(totals, level) {
                let html = '<div class="section-totals">';
                html += '<div class="totals-title">Totals</div>';
                html += '<div class="totals-grid">';

                for (let [field, total] of Object.entries(totals)) {
                    const trimmedField = field.trim();
                    const prefix = prefixMap[field] || fieldPrefix[trimmedField] || '';
                    const suffix = fieldSuffix[trimmedField] || '';
                    const formattedTotal = total.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                    html += `
                <div class="total-item">
                    <span class="total-label">Total ${field}:</span>
                    <span class="total-value">${prefix}${formattedTotal}${suffix}</span>
                </div>
            `;
                }

                html += '</div></div>';
                return html;
            }

            //Modify Field Alignment
            function getFieldAlignment(fieldName, sampleValue) {
                // Currency prefixes to check for
                const currencyPrefixes = ['$', '€', '£', '₹', '¥', '₩', '₽', '₦', '₪'];

                // Check if field or sample value starts with currency symbol
                const fieldHasCurrency = currencyPrefixes.some(prefix =>
                    fieldName.includes(prefix) || (sampleValue && sampleValue.toString().trim().startsWith(prefix))
                );

                if (fieldHasCurrency) {
                    // console.log('Currency detected in field:', fieldName, 'with sample value:', sampleValue);
                    return 'right'; // Currency fields
                }

                if (sampleValue) {
                    const trimmedValue = sampleValue.toString().trim();

                    // Check if it contains any letters (text)
                    if (/[a-zA-Z]/.test(trimmedValue)) {
                        return 'left'; // Text fields
                    }

                    // Check if it's a pure number
                    if (!isNaN(parseFloat(trimmedValue)) && isFinite(trimmedValue)) {
                        return 'center'; // Number fields
                    }

                    // Check if it's a date
                    if (!isNaN(Date.parse(trimmedValue))) {
                        return 'center'; // Date fields
                    }
                }

                return 'left'; // Default to left alignment
            }


            // Generate Body Table
            function generateBodyTable(data, sortKeys, tableData_) {
                const sortedData = multiSort(data, sortKeys);
                const displayFields = bodyFieldOrder || Object.keys(data[0]).filter(key => !sortKeys.includes(key) && !sortKeys.includes(` ${key}`));

                // Further sort the body records by bodySortOrder
                if (bodySortOrder && Array.isArray(bodySortOrder) && bodySortOrder.length > 0) {
                    sortedData.sort((a, b) => {
                        for (const sortSpec of bodySortOrder) {
                            const column = sortSpec.Column;
                            const order = sortSpec.Order.toLowerCase();

                            if (a[column] === undefined || b[column] === undefined) continue;

                            const valA = a[column];
                            const valB = b[column];
                            const numA = parseFloat(valA);
                            const numB = parseFloat(valB);
                            const bothAreNumbers = !isNaN(numA) && !isNaN(numB);

                            let compareA = bothAreNumbers ? numA : valA;
                            let compareB = bothAreNumbers ? numB : valB;

                            if (compareA !== compareB) {
                                if (order === 'asc') {
                                    return compareA < compareB ? -1 : 1;
                                } else {
                                    return compareA > compareB ? -1 : 1;
                                }
                            }
                        }
                        return 0;
                    });
                }

                let html = `<table class="body-table" data-table-heading="${tableData_}"><thead><tr>`;
                displayFields.forEach(field => {
                    const sampleValue = sortedData[0]?.[field];
                    const samplePrefix = prefixMap[field] || fieldPrefix[field.trim()] || '';
                    const fullSampleValue = samplePrefix + (sampleValue || '');
                    const alignment = getFieldAlignment(field, fullSampleValue);
                    html += `<th style="text-align: ${alignment}">${field.trim()}</th>`;

                });
                html += '</tr></thead><tbody>';

                sortedData.forEach(row => {
                    html += '<tr>';
                    displayFields.forEach(field => {
                        const trimmedField = field.trim();
                        const prefix = prefixMap[field] || fieldPrefix[trimmedField] || '';
                        const suffix = fieldSuffix[trimmedField] || '';

                        let cellValue = row[field];
                        const hasCurrencyPrefix = prefix && ['$', '€', '£', '₹', '¥', '₩', '₽', 'R', '₦', '₪']
                        if (((/total|sum/i).test(field) || hasCurrencyPrefix)&& !isNaN(parseFloat(cellValue))) {
                            cellValue = parseFloat(cellValue).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                        }
                        const fullCellValue = prefix + (cellValue || '') + suffix;
                        const alignment = getFieldAlignment(field, fullCellValue);
                        html += `<td style="text-align: ${alignment}">${prefix}${cellValue || ''}${suffix}</td>`;
                    });
                    html += '</tr>';
                });

                html += '</tbody></table>';
                return html;
            }

            // Generate Trailing Grand Summary
            function generateTrailingSummary(summaryFields, bodyData) {
                let totals = {};
                if (!summaryFields || summaryFields.length === 0) {
                    return ''; // Do not render anything
                }
                summaryFields.forEach(field => {
                    const trimmedField = field.trim();
                    totals[trimmedField] = bodyData.reduce((sum, row) => sum + (parseFloat(row[trimmedField]) || 0), 0);
                });

                let html = '<div class="trailing-summary"><h3>Grand Total</h3><table>';
                for (let [field, total] of Object.entries(totals)) {
                    const trimmedField = field.trim();
                    const prefix = prefixMap[field] || fieldPrefix[trimmedField] || '';
                    const suffix = fieldSuffix[trimmedField] || '';
                    const formattedTotal = total.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                    html += `<tr><td>Total ${field}</td><td>${prefix}${formattedTotal}${suffix}</td></tr>`;
                }
                html += '</table></div>';
                return html;
            }

            // Main report generation
            let reportHtml = '<div class="dynamic-report" id="dynamic-printable-report">';

            // Add current date
            reportHtml += `<div class="current-date">${new Date().toLocaleDateString()}</div>`;

            // Find and generate Title Header
            const titleHeader = jsonData.find(item => 'TitleHeader' in item);
            if (titleHeader) {
                reportHtml += generateTitleHeader(titleHeader.TitleHeader);
            }

            // Find Body data
            const bodyData = jsonData.find(item => 'Body' in item)?.Body.BodyField;
            const bodySortKeys = jsonData.find(item => 'Body' in item)?.Body.Sorting || [];
            const bodyFieldOrder = jsonData.find(item => 'Body' in item)?.Body.BodyFieldOrder || [];
            const bodySortOrder = jsonData.find(item => 'Body' in item)?.Body.BodySortOrder || [];

            // Extract prefix and suffix configurations
            const fieldPrefix = jsonData.find(item => 'Body' in item)?.Body.FieldPrefix || {};
            const fieldSuffix = jsonData.find(item => 'Body' in item)?.Body.FieldSuffix || {};

            if (bodyData) {
                // Find and generate Subsummaries
                const subsummaries = jsonData.filter(item => 'Subsummary' in item).map(item => item.Subsummary);
                reportHtml += generateNestedSubsummaries(bodyData, subsummaries);

                // Find and generate Trailing Grand Summary
                const trailingSummary = jsonData.find(item => 'TrailingGrandSummary' in item);
                if (trailingSummary) {
                    reportHtml += generateTrailingSummary(trailingSummary.TrailingGrandSummary.TrailingGrandSummary, bodyData);
                }
            }

            reportHtml += '</div>';
            return reportHtml;
        }


        // Store original display states before disabling pagination
        let originalDisplayStates = new Map();
        function disablePagination() {
            const topLevelSubsummaries = Array.from(document.querySelectorAll('.dynamic-report > .subsummary.level-0'));
            const trailingSummary = document.querySelector('.trailing-summary');

            // Store current display states
            topLevelSubsummaries.forEach(summary => {
                originalDisplayStates.set(summary, summary.style.display);
                summary.style.display = 'block'; // Show all content
            });

            // Always show trailing summary for print
            if (trailingSummary) {
                originalDisplayStates.set(trailingSummary, trailingSummary.style.display);
                trailingSummary.style.display = 'block';
            }

            // Hide pagination controls
            const paginationControls = document.querySelector('.pagination-controls'); // Adjust selector as needed
            if (paginationControls) {
                originalDisplayStates.set(paginationControls, paginationControls.style.display);
                paginationControls.style.display = 'none';
            }
        }

        // Function to restore pagination
        function enablePagination() {
            // Restore all original display states
            originalDisplayStates.forEach((originalDisplay, element) => {
                element.style.display = originalDisplay;
            });

            // Clear the stored states
            originalDisplayStates.clear();

            // Trigger a page update if you have access to pagination instance
            // This assumes your pagination has some way to refresh the current view
            if (typeof paginationInstance !== 'undefined' && paginationInstance && paginationInstance.recalculatePages) {
                paginationInstance.recalculatePages();
            }
        }

        // Modified PDF export function
        async function exportPdf() {
            try {
                // Disable pagination before printing
                disablePagination();

                // Small delay to ensure DOM updates are complete
                await new Promise(resolve => setTimeout(resolve, 100));

                // Open print dialog
                window.print();

                // Listen for after print event to re-enable pagination
                const afterPrint = () => {
                    enablePagination();
                    window.removeEventListener('afterprint', afterPrint);
                };

                window.addEventListener('afterprint', afterPrint);

                // Fallback: re-enable pagination after a delay in case afterprint doesn't fire
                setTimeout(() => {
                    if (originalDisplayStates.size > 0) {
                        enablePagination();
                    }
                }, 1000);

            } catch (error) {
                console.error('Error during PDF export:', error);
                // Ensure pagination is re-enabled even if there's an error
                enablePagination();
            }
        }

async function exportTableToServer() {
    disablePagination(); // Disable pagination initially

    const tables = document.querySelectorAll('.body-table');
    const sections = [];

    // Build Subsummary map from global jsonData
    const subsummaryTotalsMap = {};
    if (Array.isArray(jsonData)) {
        jsonData.forEach(entry => {
            if (entry.Subsummary && Array.isArray(entry.Subsummary.SubsummaryTotal)) {
                const groupField = entry.Subsummary.SubsummaryFields?.[0]?.trim();
                if (groupField) {
                    subsummaryTotalsMap[groupField] = new Set(entry.Subsummary.SubsummaryTotal.map(f => f.trim()));
                }
            }
        });
    }

    // Process each subsummary table
    tables.forEach(table => {
        const heading = table.getAttribute('data-table-heading') || "";
        const rows = Array.from(table.rows);
        if (rows.length === 0) return;

        const headers = Array.from(rows[0].cells).map(cell => cell.textContent.trim());
        const dataRows = rows.slice(1).map(row =>
            Array.from(row.cells).map(cell => cell.textContent.trim())
        );

        // Get the first part of heading (group field name)
        const groupKey = heading.split('_')[0]?.split('-')[0]?.trim();
        const targetFields = subsummaryTotalsMap[groupKey] || new Set();
        const summary = {};

        headers.forEach((header, colIndex) => {
            if (!targetFields.has(header)) return;
            
            let prefix = '';
            let total = 0;
            
            dataRows.forEach(row => {
                const val = row[colIndex];
                // Extract prefix (currency symbols, etc.)
                const match = val.match(/^([^\d\-.,]*)/);
                if (match && match[1]) {
                    prefix = match[1];
                }
                // Extract numeric value
                const cleaned = val.replace(/[^0-9.\-]/g, '');
                const num = parseFloat(cleaned);
                
                if (!isNaN(num)) total += num;
            });
            
            summary[header] = prefix + total.toFixed(2);
        });

        sections.push({
            title: heading,
            headers,
            rows: dataRows,
            summary
        });
    });

    const payload = { sections };

    try {
        const response = await fetch("https://kibiai-excel-formatter.onrender.com/generate-excel", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            throw new Error("Excel generation failed");
        }

        const blob = await response.blob();
        const blobUrl = URL.createObjectURL(blob);

        // Prompt Save File dialog
        const a = document.createElement("a");
        a.href = blobUrl;
        a.download = "report.xlsx";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(blobUrl);

    } catch (err) {
        alert("Failed to generate Excel: " + err.message);
    }

    enablePagination(); // Re-enable pagination after export
}




        function safeFilemakerCall(scriptName, param) {
            const bridge = window.Filemaker || filemakerBridge;
            if (bridge && typeof bridge.PerformScript === 'function') {
                bridge.PerformScript(scriptName, param);
            } else {
                console.warn("Filemaker bridge not available. Retrying..."); setTimeout(() => {
                    const retryBridge = window.Filemaker;
                    if (retryBridge && typeof retryBridge.PerformScript === 'function') {
                        retryBridge.PerformScript(scriptName, param);
                    } else {
                        console.error("Filemaker bridge still unavailable.");
                    }
                }, 250);
            }
        }


        function toggleLoader() {
            const loader = document.getElementById('loader');
            if (loader.style.display === 'none') {
                loader.style.display = 'block';
            } else {
                loader.style.display = 'none';
            }
        }

        function init() {
            const reportHtml = generateDynamicReport(jsonData);
            document.getElementById('dynamic-report').innerHTML = reportHtml;
            const currentDate = new Date().toLocaleDateString();
            const currentDateLabelHtml = `<div class="current-date" >Date: ${currentDate}</div>
`;

            document.getElementById('dynamic-printable-report').insertAdjacentHTML('beforeend', currentDateLabelHtml);
            pagination = initializeA4Pagination();
            initializeThemeSwitcher();

            setTimeout(() => {
                console.log(insightData)
                FileMaker.PerformScript("Save_Insight", insightData);
            }, 500);
        }
        window.onload = init;
    </script>
</body>

</html>